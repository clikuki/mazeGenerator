<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Maze Visualizations</title>
		<link rel="stylesheet" type="text/css" href="style.css" />
		<script src="dest/index.js" type="module"></script>
	</head>
	<body>
		<canvas></canvas>
		<div class="ui">
			<h1>Maze Algorithm Visualizations</h1>
			<div class="options">
				<div class="inputs">
					<div class="buttons">
						<button class="step">Step</button>
						<button class="pause">Pause</button>
						<button class="restart">Restart</button>
						<button class="fastForward">Fast Forward</button>
						<button
							class="exportAsImage"
							title="Walls can be more than 1px wide, so reading image file for walls and stuff will be hard"
						>
							Export as PNG
						</button>
						<button
							class="exportAsGrid"
							title="JSON format:
[
	{
		// Position in grid
		x: number,
		y: number,

		// Walls on four sides
		top: boolean,
		right: boolean,
		bottom: boolean,
		left: boolean,
	}
]"
						>
							Export as grid
						</button>
						<button
							class="exportAsGraph"
							title="JSON format:
{
	// id with array of more Id's showing adjacencies
	<Id>: Id[]
}"
						>
							Export as graph
						</button>
					</div>
					<div class="misc">
						<div class="algoType">
							<label for="algoTypeInput">Algorithm</label>
							<select id="algoTypeInput"></select>
						</div>
						<label>Columns<input type="number" class="column" min="3" /></label>
						<label>Rows<input type="number" class="row" min="3" /></label>
						<div class="stepsPerSecond">
							<label
								for="stepsPerSecondInput"
								title="Limits how many steps simulation can take in a second"
								>Max steps per Second</label
							>
							<button>Uncapped</button>
							<input id="stepsPerSecondInput" type="number" min="0" disabled />
						</div>
						<div class="pathDrawMethod">
							<label for="pathDrawMethodInput" title="Type of path visualization"
								>Path Draw Method</label
							>
							<select id="pathDrawMethodInput"></select>
						</div>
					</div>
					<div class="mazeAlgo">
						<div class="binaryTree">
							<label for="binaryTreeInput">Binary Tree Direction</label>
							<select id="binaryTreeInput">
								<option value="NORTH-WEST">North-West</option>
								<option value="NORTH-EAST">North-East</option>
								<option value="SOUTH-WEST">South-West</option>
								<option value="SOUTH-EAST">South-East</option>
							</select>
						</div>
						<div class="ellersJoinSetEdges">
							<label>Eller's: Join set edges</label>
							<button></button>
						</div>
					</div>
				</div>
			</div>
			<p style="font-style: italic;">
				Once the maze has finished generating, click on any two cells to find a path
				between them.
			</p>
			<div class="algorithm-list">
				<h2>Algorithms Used</h2>
				<ul>
					<li>
						<span>Recursive Backtracking</span>
						<ul>
							<li>
								Creates a path while avoiding itself and the walls. When a dead-end is
								reached, it backtracks until it reaches open space to branch away
							</li>
							<li>Slow - Only updates one cell per step</li>
							<li>Long, winding corridors</li>
							<li>Few branches</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Recursive Division</span>
						<ul>
							<li>
								Splits an area into two smaller and smaller pieces until an area is as
								small as it can be
							</li>
							<li>
								Very quick - Can quickly split large spaces into smaller chambers
							</li>
							<li>
								Has obvious walls and bottlenecks due to how recursively cut rectangles
								into smaller and smaller rectangles within itself
							</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Aldous-Broder algorithm</span>
						<ul>
							<li>
								Walks randomly around the grid, carving walls between cells when
								reaching an unvisited cell
							</li>
							<li>
								Creates a uniformly spanning tree, ie. corridors, dead-ends, and
								junctions are completely random, and the maze has no distinguishable
								features unlike Recursive Division's chambers
							</li>
							<li>
								Very slow - Fast in the beginning but slows down by the end, as there
								are less cells to carve
							</li>
							<li>Not guaranteed to finish - Could keep generating for forever!</li>
						</ul>
					</li>
					<li>
						<span>Wilson's algorithm</span>
						<ul>
							<li>
								Walks randomly around the grid, keeping track of its starting cell and
								the directions it took from each cell. When it encounters a visited
								cell, it creates a corridor from the path it took, then repeats the
								process until all cells are visited
							</li>
							<li>Creates a uniformly spanning tree</li>
							<li>
								Very slow - Slow at the start as there is less visited cells, but gets
								faster as it creates more corridors for it to path back to
							</li>
							<li>Not guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span> Aldous-Broder + Wilson's hybrid algorithm </span>
						<ul>
							<li>
								A mix of the Aldous-Broder and Wilson's algorithm, using the former at
								the start to create a large amount of visited cells for the latter to
								path back to
							</li>
							<li>
								May not create a uniformly spanning tree (Haven't researched that yet)
							</li>
							<li>
								Average to slow - Faster than its constituent algorithms but still takes
								longer than other algorithms due to its randomness
							</li>
							<li>Not guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Binary Tree</span>
						<ul>
							<li>
								For each cell, it randomly picks between 2 perpendicular directions and
								carves a wall in that direction
							</li>
							<li>Quick</li>
							<li>Creates a binary tree, as the name suggests</li>
							<li>
								Has a strong diagonal bias, as well as long corridors at the two end
								edges
							</li>
							<li>
								Memory efficient - Its main selling point. As it only looks at the
								current cell, it doesn't need any state. If using a seedable RNG,
								instead of keeping the maze in memory, it can just regenerate the maze
								when needed. This allows for absolutely massive mazes that don't use too
								much memory
							</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Kruskal's</span>
						<ul>
							<li>
								Gather a list of all edges in the maze. Pick one at random, and if the
								cells at each side of the edge are disconnected, carve the wall between
								them. Remove the edge from the list, then repeat picking and carving
								until all edges have been picked or the maze is completly connected
							</li>
							<li>
								Slow - the number of edges are directly proportional to the width and
								height of the grid
							</li>
							<li>Creates many short dead-ends</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Prim's</span>
						<ul>
							<li>
								Open a random cell in the grid, and add its neighbors to a list. Pick
								and remove a random cell in the list, add its neighbors to the list,
								then carve a wall from it to an open neigbor. Repeat until all cells are
								connected
							</li>
							<li>Slow - Only updates one cell per step</li>
							<li>Creates many short dead-ends</li>
							<li>
								All paths tend to go back to the algorithm's starting point, which may
								undesirable
							</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Eller's</span>
						<ol>
							<li>In a row, put each cell into their own set.</li>
							<li>Randomly merge cells that are disjoint/in separate sets.</li>
							<li>Pick one cell from each set and carve down into the next row.</li>
							<li>
								Put the remaining closed cells of the next row into their own set
							</li>
							<li>Repeat steps 2 - 4 until the last row is reached.</li>
							<li>
								Connect every disjoint cell in the last row so that every set is
								combined into one
								<br />
								<span style="font-style: italic; font-weight: bold;">OR</span>
								<br />
								While there is more than one set, randomly carve walls between disjoint
								sets and merge them
								<br />
							</li>
						</ol>
						<ul>
							<li>
								Slow/Quick - Can be fast if set operations are fast and went row-by-row
								instead cell by cell
							</li>
							<li>Can create infinitely long or tall mazes</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<span
						style="font-style: italic; color: #222; margin-top: .5rem; display: inline-block;"
						>EXTRA: Maze Solver algorithm</span
					>
					<li>
						<span>Flood-Fill Algorithm</span>
						<ul>
							<li>
								Finds every dead-end in the maze and fills them in until it reaches a
								junction. This keeps into account filled-in cells by the algorithm until
								no cell can be fill in anymore.
							</li>
							<li>
								If a maze is imperfect (has loops, multiple solutions), it will feature
								two unfilled paths. A BFS algorithm or similar can be used to find the
								shortest route
							</li>
							<li>
								Requires full knowledge of the maze, unlike other algorithms that use
								walkers
							</li>
						</ul>
					</li>
				</ul>
			</div>
		</div>
	</body>
</html>
