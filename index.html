<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Maze Visualizations</title>
		<link rel="stylesheet" type="text/css" href="style.css" />
		<script src="dest/index.js" type="module"></script>
	</head>
	<body>
		<canvas></canvas>
		<div class="ui">
			<h1>Maze Algorithm Visualizations</h1>
			<div class="options">
				<div class="inputs">
					<div class="buttons">
						<button class="step">Step</button>
						<button class="pause">Pause</button>
						<button class="restart">Restart</button>
						<button class="fastForward">Fast Forward</button>
						<button
							class="exportAsImage"
							title="Walls can be more than 1px wide, so reading image file for walls and stuff will be hard"
						>
							Export as PNG
						</button>
						<button
							class="exportAsGrid"
							title="JSON format:
[
	{
		// Position in grid
		x: number,
		y: number,

		// Walls on four sides
		top: boolean,
		right: boolean,
		bottom: boolean,
		left: boolean,
	}
]"
						>
							Export as grid
						</button>
						<button
							class="exportAsGraph"
							title="JSON format:
{
	// id with array of more Id's showing adjacencies
	<Id>: Id[]
}"
						>
							Export as graph
						</button>
						<br />
					</div>
					<div class="misc">
						<div class="algoType">
							<label for="algoTypeInput">Algorithm</label>
							<select id="algoTypeInput"></select>
						</div>
						<label>Columns<input type="number" class="column" min="3" /></label>
						<label>Rows<input type="number" class="row" min="3" /></label>
						<div class="stepsPerSecond">
							<label
								for="stepsPerSecondInput"
								title="Limits how many steps simulation can take in a second"
								>Max steps per Second</label
							>
							<button>Uncapped</button>
							<input id="stepsPerSecondInput" type="number" min="0" disabled />
						</div>
						<div class="pathDrawMethod">
							<label for="pathDrawMethodInput" title="Type of path visualization"
								>Path Draw Method</label
							>
							<select id="pathDrawMethodInput"></select>
						</div>
					</div>
					<div class="mazeAlgo">
						<div class="binaryTree">
							<label for="binaryTreeInput">Binary Tree Direction</label>
							<select id="binaryTreeInput">
								<option value="NORTH-WEST">North-West</option>
								<option value="NORTH-EAST">North-East</option>
								<option value="SOUTH-WEST">South-West</option>
								<option value="SOUTH-EAST">South-East</option>
							</select>
						</div>
					</div>
				</div>
			</div>
			<p style="font-style: italic;">
				Once the maze has finished generating, click on any two cells to find a path
				between them.
			</p>
			<div class="algorithm-list">
				<h2>Algorithms Used</h2>
				<ul>
					<li>
						<span>Recursive Backtracking</span>
						<ul>
							<li>
								Creates a path while avoiding itself and the walls. When a dead-end is
								reached, it backtracks until it reaches open space to branch away
							</li>
							<li>Average speed</li>
							<li>Long, winding corridors</li>
							<li>Few branches</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Recursive Division</span>
						<ul>
							<li>
								Splits an area into two smaller areas recursively until an area is as
								small as it can be
							</li>
							<li>
								Very quick - Can quickly split large spaces into smaller chambers
							</li>
							<li>
								Ugly - Has obvious walls and bottlenecks due to how recursively cut
								rectangles into smaller and smaller rectangles within itself
							</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Aldous-Broder algorithm</span>
						<ul>
							<li>
								Walks randomly around the grid, carving walls between cells when
								reaching an unvisited cell
							</li>
							<li>
								Creates a uniformly spanning tree, ie. corridors, dead-ends, and
								junctions are completely random, and the maze has no distinguishable
								features unlike Recursive Division's chambers
							</li>
							<li>
								Very slow - Fast in the beginning but slows down by the end, as there
								are less cells to carve
							</li>
							<li>Not guaranteed to finish - Could keep generating for forever!</li>
						</ul>
					</li>
					<li>
						<span>Wilson's algorithm</span>
						<ul>
							<li>
								Walks randomly around the grid, keeping track of its starting cell and
								the directions it took from each cell. When it encounters a visited
								cell, it creates a corridor from the path it took, then repeats the
								process until all cells are visited
							</li>
							<li>Creates a uniformly spanning tree</li>
							<li>
								Very slow - Slow at the start as there is less visited cells, but gets
								faster as it creates more corridors for it to path back to
							</li>
							<li>Not guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span> Aldous-Broder + Wilson's hybrid algorithm </span>
						<ul>
							<li>
								A mix of the Aldous-Broder and Wilson's algorithm, using the former at
								the start to create a large amount of visited cells for the latter to
								path back to
							</li>
							<li>
								May not create a uniformly spanning tree (Haven't researched that yet)
							</li>
							<li>
								Average to slow - Faster than its constituent algorithms but still takes
								longer than other algorithms due to its randomness
							</li>
							<li>Not guaranteed to finish</li>
						</ul>
					</li>
					<li>
						<span>Binary Tree</span>
						<ul>
							<li>
								For each cell, it randomly picks between 2 perpendicular directions and
								carves a wall in that direction
							</li>
							<li>Quick</li>
							<li>Creates a binary tree, as the name suggests</li>
							<li>
								Ugly - Has a strong diagonal bias, as well as long corridors at the two
								end edges
							</li>
							<li>
								Memory efficient - Its main selling point. As it only looks at the
								current cell, it doesn't need any state. If using a seedable RNG,
								instead of keeping the maze in memory, it can just regenerate the maze
								when needed. This allows for absolutely massive mazes that don't use too
								much memory
							</li>
							<li>Guaranteed to finish</li>
						</ul>
					</li>
					<span
						style="font-style: italic; color: #222; margin-top: .5rem; display: inline-block;"
						>EXTRA: Maze Solver algorithm</span
					>
					<li>
						<span>Flood-Fill Algorithm</span>
						<ul>
							<li>
								Finds every dead-end in the maze and fills them in until it reaches a
								junction. This keeps into account filled-in cells by the algorithm until
								no cell can be fill in anymore.
							</li>
							<li>
								If a maze is imperfect (has loops, multiple solutions), it will feature
								two unfilled paths. A BFS algorithm or similar can be used to find the
								shortest route
							</li>
							<li>
								Requires full knowledge of the maze, unlike other algorithms that use
								walkers
							</li>
						</ul>
					</li>
				</ul>
			</div>
		</div>
	</body>
</html>
